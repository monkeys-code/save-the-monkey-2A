# 56. Merge Intervals

ì¶œì œì: ìŠ¤í…”ë¼

[ë¬¸ì œ - Merge Intervals ](https://leetcode.com/problems/merge-intervals/)

- ì¶œì œ ì´ìœ 
  - medium ìœ¼ë¡œ ë‚œì´ë„ë¥¼ ì˜¬ë¦° ì²« ì‹œê°„ì´ë¼ì„œ accept rate ê°€ ë†’ì€ ë¬¸ì œë¥¼ ì„ ì •í–ˆë‹¤.
  - edge caseê°€ ì—¬ëŸ¬ê°œ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ë¬¸ì œì—¬ì„œ ì´ì— ëŒ€ì‘í•˜ëŠ” ë²•ì„ ì—°ìŠµí•  ìˆ˜ ìˆë‹¤.
  - ë‹¤ì–‘í•œ í’€ì´ë²•ì´ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ë¬¸ì œë¼ì„œ ì—¬ëŸ¬ ë°©ë²•ì„ ê³ ë¯¼í•´ë³¼ ìˆ˜ ìˆë‹¤.

## Latte
![](./images/20200119_56_latte.jpeg)

---

## Kevin

- ì²˜ìŒì— ë¼ë–¼ì˜ ì ‘ê·¼ ë°©ì‹ì„ ë³´ê³  ì˜¤! ì•„ì£¼ creativeí•œ ë°©ë²•ì¸ê±°ê°™ë‹¤! ì‹¶ì—ˆëŠ”ë° ì§„í–‰ë˜ëŠ”ê±¸ ë³´ë©´ì„œ ê·¸ëƒ¥ ì†ŒíŒ…í•˜ê³  ê¸°ì¡´ëŒ€ë¡œ í•˜ëŠ”ê²Œ ë‚˜ì•˜ê² ë‹¤.. ë¼ëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤ ã…‹ã…‹ã…‹ã…‹ã…‹ã…‹
- ê·¸ ì™¸ì—ë„ í .. ë’¤ì—ì„œ ì§€ì¼œë³´ë©´ì„œ **ë‚˜ëŠ” ì•ìœ¼ë¡œ ì–´ë–»ê²Œ í’€ì–´ê°€ì•¼ í• ì§€**ì— ëŒ€í•œ ì—¬ëŸ¬ê°€ì§€ ìƒê°ì´ ë“¤ì—ˆëŠ”ë° ì•„ì§ ìƒê°ì´ ì •ëˆë˜ì§„ ì•Šì•˜ê¸°ì— ë‹¤ìŒì— ê³µìœ  ğŸ’â€â™‚ï¸.
- í’€ì–´ë³´ê¸° ì¬ë°ŒëŠ” ë¬¸ì œë¼ê³  ìƒê°í•œë‹¤.

---

## Stella
### ì˜ˆì‹œ ë‹µë³€ 1
```python
class Solution:
    def merge(self, intervals):
        intervals.sort(key=lambda x: x.start)
        merged = []
        for interval in intervals:
            # if the list of merged intervals is empty or if the current
            # interval does not overlap with the previous, simply append it.
            if not merged or merged[-1].end < interval.start:
                merged.append(interval)
            else:
            # otherwise, there is overlap, so we merge the current and previous
            # intervals.
                merged[-1].end = max(merged[-1].end, interval.end)
        return merged
```
* intervals ë¥¼ ì²«ë²ˆì§¸ element ê¸°ì¤€ìœ¼ë¡œ sorting ì„ í•œ í›„ í’€ì´ë¥¼ ì‹œì‘í•˜ë©´ ê°„ë‹¨í•´ì§„ë‹¤.
* intervals ì˜ elelemt ë“¤ì„ í•˜ë‚˜ì”© ëŒë©´ì„œ merged list ì´ ë¹„ì–´ìˆê±°ë‚˜, overlap ì´ ì—†ë‹¤ë©´ í˜„ì¬ interval ì„ merged ì— append í•œë‹¤.
* overlap ì´ ìˆë‹¤ë©´ ë§ˆì§€ë§‰ merged ì˜ ë§ˆì§€ë§‰ element ì— ë‘ë²ˆì§¸ ê°’ì„ í˜„ì¬ interval ì˜ ë‘ë²ˆì§¸ ê°’ìœ¼ë¡œ ì¹˜í™˜í•´ì¤€ë‹¤.

### ì˜ˆì‹œ ë‹µë³€ 2
```python
class Solution(object):
    def merge(self, intervals):
        if len(intervals)<=1:
            return intervals
        s_inte=sorted(intervals, key=lambda e: e[0])
        
        ans=[s_inte[0]]
        flag=1
        
        for i in range(1, len(s_inte)):
            if flag==0:
                first=s_inte[i-1]
            else:
                first=ans[-1]
            second=s_inte[i]

            if second[0] <= first[1]:# overlap
                flag=1
                ans.pop()
                ans+=[[first[0], max(first[1], second[1])]]
            else:
                flag=0
                ans+=[second]
        return ans
```
* ì˜ˆì‹œë‹µë³€ 1ê³¼ ê°™ì€ ì»¨ì…‰ì´ì§€ë§Œ ì¡°ê¸ˆ ë” ì§ê´€ì ì´ë©´ì„œë„ ëœ ì •ëˆëœ í’€ì´ì´ë‹¤.
* ì´ì „í•­ì— overlap ì´ ìˆì—ˆë‹¤ë©´(flag ë¡œ í‘œì‹œ) ê·¸ ë‹¤ìŒí•­ì—ì„œ ë¹„êµí•  ëŒ€ìƒì„ ans(ë‹µë³€)ì˜ ë§ˆì§€ë§‰ ê°’ì´ ë˜ë„ë¡ ì§€ì •í•œë‹¤.

### ì˜ˆì‹œ ë‹µë³€ 3
```python
class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """
        n=len(intervals)
        starts=[0]*n
        ends=[0]*n
        for i in range(n):
            starts[i]=intervals[i][0]
            ends[i]=intervals[i][1]
        starts.sort()
        ends.sort()

        res=[]
        j=0 # start of interval
        for i in range(n):
            if i==n-1 or starts[i+1]>ends[i]:
                res.append([starts[j], ends[i]])
                j=i+1
        
        return res
```
* ê° interval ë“¤ì˜ ì²«ë²ˆì§¸ í•­ list(starts)ê³¼ ë‘ë²ˆì§¸ í•­ list(ends)ë¥¼ ê°ê° ë§Œë“¤ê³  ì •ë ¬í•œë‹¤.
* starts ì™€ ends ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ëŒë©´ì„œ interval ì´ ì´ë¤„ì§ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ë¥¼ í™•ì¸í•˜ì—¬ res ì— append í•œë‹¤.
* ë¼ë–¼ê°€ í’€ì´ì‹œê°„ì— ì´ì™€ ìœ ì‚¬í•œ ì•„ì´ë””ì–´ë¥¼ ëƒˆì—ˆë‹¤.
